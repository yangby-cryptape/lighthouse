/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct secp256k1_sha256 {
    pub s: [u32; 8usize],
    pub buf: [::core::ffi::c_uchar; 64usize],
    pub bytes: u64,
}
#[test]
fn bindgen_test_layout_secp256k1_sha256() {
    const UNINIT: ::core::mem::MaybeUninit<secp256k1_sha256> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<secp256k1_sha256>(),
        104usize,
        concat!("Size of: ", stringify!(secp256k1_sha256))
    );
    assert_eq!(
        ::core::mem::align_of::<secp256k1_sha256>(),
        8usize,
        concat!("Alignment of ", stringify!(secp256k1_sha256))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_sha256),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_sha256),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_sha256),
            "::",
            stringify!(bytes)
        )
    );
}
extern "C" {
    pub fn secp256k1_sha256_initialize(hash: *mut secp256k1_sha256);
}
extern "C" {
    pub fn secp256k1_sha256_write(
        hash: *mut secp256k1_sha256,
        data: *const ::core::ffi::c_uchar,
        size: usize,
    );
}
extern "C" {
    pub fn secp256k1_sha256_finalize(hash: *mut secp256k1_sha256, out32: *mut ::core::ffi::c_uchar);
}
